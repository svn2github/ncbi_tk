/*  $Id$
* ===========================================================================
*
*                            PUBLIC DOMAIN NOTICE
*               National Center for Biotechnology Information
*
*  This software/database is a "United States Government Work" under the
*  terms of the United States Copyright Act.  It was written as part of
*  the author's official duties as a United States Government employee and
*  thus cannot be copyrighted.  This software/database is freely available
*  to the public for use. The National Library of Medicine and the U.S.
*  Government have not placed any restriction on its use or reproduction.
*
*  Although all reasonable efforts have been taken to ensure the accuracy
*  and reliability of the software and data, the NLM and the U.S.
*  Government do not and cannot warrant the performance or results that
*  may be obtained by using this software or data. The NLM and the U.S.
*  Government disclaim all warranties, express or implied, including
*  warranties of performance, merchantability or fitness for any particular
*  purpose.
*
*  Please cite the author in any work or product based on this material.
*
* ===========================================================================
*
* Author:  Michael Kornbluh, NCBI
*          (initial skeleton generated by script written by Pavel Ivanov)
*
* File Description:
*   Does misc tests on the CFastaReader that aren't already covered by
*   test_fasta_round_trip, etc.
*
*
* ===========================================================================
*/

// TODO: This test shows a lot of NULL pointer exceptions when it runs which,
// although they do not indicate a problem, could cause confusion.

#include <ncbi_pch.hpp>

#include <corelib/ncbi_system.hpp>
#include <corelib/ncbiapp.hpp>

// This header must be included before all Boost.Test headers if there are any
#include <corelib/test_boost.hpp>

#include <corelib/rwstream.hpp>
#include <corelib/stream_utils.hpp>
#include <corelib/ncbimisc.hpp>

#include <objects/seqset/Seq_entry.hpp>

#include <objtools/readers/fasta.hpp>
#include <objtools/readers/fasta_exception.hpp>

#include <serial/objistr.hpp>

#include <objects/misc/sequence_macros.hpp>

#include <objmgr/seq_vector.hpp>

// for places where we don't care if it throws or not
#define IGNORE_ANY_THROWS(_body) try { ((_body), true); } catch(...) { }

USING_NCBI_SCOPE;
USING_SCOPE(objects);

namespace {

    class CIgnoreBelowWarningMessageListener : 
        public CMessageListenerBase
    {   
    public:
        CIgnoreBelowWarningMessageListener() {};
        ~CIgnoreBelowWarningMessageListener() {};

        bool PutError(
            const ILineError& err ) 
        {
            switch( err.Severity() ) {
            case eDiag_Info:
            case eDiag_Trace:
                // don't store things below warning
                return true;
            case eDiag_Warning:
                StoreError(err);
                return true;
            default:
                StoreError(err);
                return false;
            }
        };
    };
}

namespace {

    // Each SWarningTest has one SOneWarningsInfo for each
    // warning that might appear.
    struct SOneWarningsInfo {
        ILineError::EProblem m_eType;
        string   m_sFeatureName; // can be empty
        unsigned int m_iLineNumExpected; // might be zero for multiple-line errors

        int Compare(const SOneWarningsInfo & rhs) const;

        bool operator == (const SOneWarningsInfo & rhs) const { return 0 == Compare(rhs); }
        bool operator != (const SOneWarningsInfo & rhs) const { return 0 != Compare(rhs); }
        bool operator <  (const SOneWarningsInfo & rhs) const { return Compare(rhs) < 0; }
    };

    int SOneWarningsInfo::Compare(const SOneWarningsInfo & rhs) const {
        if( m_eType != rhs.m_eType ) {
            return static_cast<int>(m_eType) -
                static_cast<int>(rhs.m_eType);
        }
        int feat_comparison = m_sFeatureName.compare(rhs.m_sFeatureName);
        if( 0 != feat_comparison ) {
            return feat_comparison;
        }
        return m_iLineNumExpected - rhs.m_iLineNumExpected;
    }

    ostream & operator <<( ostream & ostrm, const SOneWarningsInfo & info )
    {
        ostrm << "(problem: " << ILineError::ProblemStr(info.m_eType) 
              << ", feature: " << info.m_sFeatureName 
              << ", line num: " << info.m_iLineNumExpected << ")";
        return ostrm;
    }

    // represents information about one test of the CFastaReader warning system
    struct SWarningTest {
    
        string                m_sName; // easier than array index for humans to understand
        // In m_warnings_expected, the list of warnings ends with a problem of value 0
        // (although that's really enum eProblem_UnrecognizedFeatureName, that problem
        // is irrelevant for FASTA)
        SOneWarningsInfo      m_warnings_expected[ILineError::eProblem_GeneralParsingError];
        CFastaReader::TFlags  m_fFastaFlags;
        string                m_sInputFASTA;
    };

    const static CFastaReader::TFlags kDefaultFastaReaderFlags = 
        CFastaReader::fAssumeNuc | 
        CFastaReader::fForceType;

    // list of FASTA warning tests
    const SWarningTest fasta_warning_test_arr[] = {
        { 
            "test case of no warnings",

            { },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah \n"
            "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "title too long",

            {
                { ILineError::eProblem_TooLong, "defline", 1 },
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ ABCDEFGHIJ\n"
            "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "nucs in title",

            {
                { ILineError::eProblem_UnexpectedNucResidues, "defline", 1 },
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
            "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "too many ambig on first line",

            {
                { ILineError::eProblem_TooManyAmbiguousResidues, "first data line", 2 },
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah\n"
            "ACGTACGTACGTNNNNNNNNNNNNNNNTUYYYYYYYYYYYYYYYYYYYYYYYYYYTACGT\n"
        },

        {
            "invalid residue on first line",

            {
                { ILineError::eProblem_InvalidResidue,  "", 0 },
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah\n"
            "ACEACGTAEEEACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "invalid residue on subsequent line",

            {
                { ILineError::eProblem_InvalidResidue, "", 0 },
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah\n"
            "ACGACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n"
            "ACEACGTACGTACGTAEETACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "amino acids in title",

            {
                { ILineError::eProblem_UnexpectedAminoAcids, "defline",    1 },
//                { ILineError::eProblem_Missing, "sequence", 1 },
            },

            //kDefaultFastaReaderFlags, // CFastaReader flags
            kDefaultFastaReaderFlags | CFastaReader::fDisableNoResidues, // CFastaReader flags
            "> blah ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\n"
        },

        {
            "trigger as many warnings as possible",

            {
                { ILineError::eProblem_TooLong, "defline", 1 },
                { ILineError::eProblem_UnexpectedNucResidues, "defline", 1 },
                { ILineError::eProblem_TooManyAmbiguousResidues, "first data line", 2 },
                { ILineError::eProblem_InvalidResidue, "", 0 },
                { ILineError::eProblem_ModifierFoundButNoneExpected, "defline", 1 },
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah [topology=linear] ACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTACACGTACGTAC\n"
            "ACGACNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNGTEACGTACGTACGT\n"
        },

        {
            "invalid residue on multiple lines",

            {
                { ILineError::eProblem_InvalidResidue, "",    0 },
            },
            kDefaultFastaReaderFlags, // CFastaReader flags
            "> blah\n"
            "ACACEACGTACGTACGTEEEETACGTACGTACGTACGTACGTACGTA\n"
            "ACEACGTACGTACGTAEETACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "Make sure it reads modifiers if requested",

            {
            },
                // Note: non-default flags
                CFastaReader::fAddMods | kDefaultFastaReaderFlags, // CFastaReader flags
                "> blah [topology=linear]\n"
                "ACACAACGTACGTACGTAAAATACGTACGTACGTACGTACGTACGTA\n"
                "ACAACGTACGTACGTAAATACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "Test unexpected mods on line other than first line",

            {
                { ILineError::eProblem_ModifierFoundButNoneExpected, "defline",    4 },
            },
                kDefaultFastaReaderFlags, // CFastaReader flags
                ">blah \n"
                "ACACAACGTACGTACGTAAAATACGTACGTACGTACGTACGTACGTA\n"
                "ACAACGTACGTACGTAAATACGTACGTACGTACGTACGTACGTACGT\n"
                ">blahblah [topology=linear]\n"
                "TCACAACGTACGTACGTAAAATACGTACGTACGTACGTACGTACGTA\n"
                "ACAACGTACGTACGTAAATACGTACGTACGTACGTACGTACGTACGT\n"
                ">blahblah2 \n"
                "GCACAACGTACGTACGTAAAATACGTACGTACGTACGTACGTACGTA\n"
                "ACAACGTACGTACGTAAATACGTACGTACGTACGTACGTACGTACGT\n"
        },

        {
            "Test that having no residues is fine if the right flag is set.",

            {
            },
                kDefaultFastaReaderFlags | CFastaReader::fNoSeqData, // CFastaReader flags
                ">blah \n"
                ">blah2 \n"
                ">blah3 \n"
        }
    };
}

namespace {
    template<typename TObjRef>
    void s_LoadObjectRefFromTextASN(
        TObjRef & pObj, const CTempString & sTextASN )
    {
        auto_ptr<CObjectIStream> pObjIStrm(
            CObjectIStream::CreateFromBuffer(
            eSerial_AsnText, 
            sTextASN.data(), sTextASN.length() ) );
        pObjIStrm->Read( &*pObj,
            pObj->GetThisTypeInfo() );
    }
}

BOOST_AUTO_TEST_CASE(TestBadResidues)
{
    const string kData = 
        ">Seq1\n"
        "AC/TACGTACGTACGTACGTACGTACGTAC/TACGTACGTACGTACGT\n"
        "AC/TACGTACGTACGTUCGTACGTACGTACGTACGTACGTACGTACGT\n"
        "AC/TACGTACGTACGTACGTACGTAC/TACGTACGTACGTACGTACGT\n";
    const static CFastaReader::TFlags kFlags = 
        CFastaReader::fAssumeNuc | 
        CFastaReader::fForceType |
        CFastaReader::fValidate;

    CMemoryLineReader line_reader( kData.c_str(), kData.length() );
    CFastaReader fasta_reader( line_reader, kFlags );
    try {
        fasta_reader.ReadOneSeq();
        BOOST_ERROR("Bad residue did not cause exception to be thrown");
    } catch(const CBadResiduesException & bad_residue_ex) {

        typedef CBadResiduesException::SBadResiduePositions::TBadIndexMap
            TBadIndexMap;
        const TBadIndexMap & bad_index_map =
            bad_residue_ex.GetBadResiduePositions().m_BadIndexMap;
        TBadIndexMap::const_iterator bad_index_it = bad_index_map.begin();

        BOOST_CHECK_EQUAL(bad_index_it->first, 2);
        vector<TSeqPos> vecExpectedPositions;
        vecExpectedPositions.push_back(2);
        vecExpectedPositions.push_back(30);
        BOOST_CHECK_EQUAL_COLLECTIONS(
            bad_index_it->second.begin(),
            bad_index_it->second.end(),
            vecExpectedPositions.begin(),
            vecExpectedPositions.end());

        ++bad_index_it;
        BOOST_CHECK_EQUAL(bad_index_it->first, 3);
        vecExpectedPositions.clear();
        vecExpectedPositions.push_back(2);
        BOOST_CHECK_EQUAL_COLLECTIONS(
            bad_index_it->second.begin(),
            bad_index_it->second.end(),
            vecExpectedPositions.begin(),
            vecExpectedPositions.end());

        ++bad_index_it;
        BOOST_CHECK_EQUAL(bad_index_it->first, 4);
        vecExpectedPositions.clear();
        vecExpectedPositions.push_back(2);
        vecExpectedPositions.push_back(26);
        BOOST_CHECK_EQUAL_COLLECTIONS(
            bad_index_it->second.begin(),
            bad_index_it->second.end(),
            vecExpectedPositions.begin(),
            vecExpectedPositions.end());
    }
}

// Test that the right warnings appear under the right conditions
BOOST_AUTO_TEST_CASE(TestWarnings)
{
    for( size_t warn_test_idx = 0; 
        warn_test_idx < ArraySize(fasta_warning_test_arr); 
        ++warn_test_idx )
    {
        const SWarningTest & warning_test = fasta_warning_test_arr[warn_test_idx];

        cout << endl;
        cout << "Running test case '" << warning_test.m_sName << "'" << endl;

        // this will hold warnings found
        CRef<CIgnoreBelowWarningMessageListener> pMessageListener( 
            new CIgnoreBelowWarningMessageListener );

        // create fasta reader
        CStringReader fastaStringReader( warning_test.m_sInputFASTA );
        CRStream fastaRStream( &fastaStringReader );
        CFastaReader fasta_reader( fastaRStream, warning_test.m_fFastaFlags );

        // do the parsing
        BOOST_CHECK_NO_THROW( fasta_reader.ReadSet(kMax_Int, pMessageListener.GetPointer()) );

        typedef set<SOneWarningsInfo> TWarningInfoSet;
        TWarningInfoSet setWarningsSeen;

        // load the warnings that were seen into warningsSeenFromThisTest
        ITERATE_0_IDX(ii, pMessageListener->Count() ) {
            const ILineError & line_error = pMessageListener->GetError(ii);
            SOneWarningsInfo warning_info = {
                line_error.Problem(),
                line_error.FeatureName(),
                line_error.Line()
            };
            setWarningsSeen.insert(warning_info);
        }

        // load the warnings that are expected
        set<SOneWarningsInfo> setExpectedWarnings;
        ITERATE_0_IDX(warning_check_idx, 
                ArraySize(warning_test.m_warnings_expected) ) 
        {
            const SOneWarningsInfo & one_warning_info = 
                warning_test.m_warnings_expected[warning_check_idx];
            const ILineError::EProblem eExpectedType = 
                one_warning_info.m_eType;
            if( static_cast<int>(eExpectedType) <= 0 ) {
                continue;
            }
            setExpectedWarnings.insert( one_warning_info );
        }

        BOOST_CHECK_EQUAL_COLLECTIONS(
            setWarningsSeen.begin(),
            setWarningsSeen.end(),
            setExpectedWarnings.begin(),
            setExpectedWarnings.end() );
    }
}

namespace {

    typedef vector<ILineError::EProblem> TWarnVec;

    // returns empty reference on error
    // (should never let exceptions escape)
    CRef<CBioseq> s_ParseFasta( const string & sFasta,
        CFastaReader::TFlags fFlags,
        const string & sExpectedExceptionErrCode = kEmptyStr,
        const TWarnVec & pExpectedWarningTypes = TWarnVec(),
        CRef<CSourceModParser::CModFilter> pModFilter =  CRef<CSourceModParser::CModFilter>(),
        set<string> expected_unused_mods = set<string>() )
    {
        CRef<CBioseq> pRetvalBioseq;
        string sErrCodeThatOccurred;
        CRef<CIgnoreBelowWarningMessageListener> pMessageListener( 
            new CIgnoreBelowWarningMessageListener );

        try {
            CMemoryLineReader line_reader( sFasta.c_str(), sFasta.length() );
            CFastaReader fasta_reader( line_reader, fFlags );
            if( pModFilter ) {
                fasta_reader.SetModFilter( pModFilter );
            }

            CRef<CSeq_entry> pEntry = fasta_reader.ReadOneSeq(pMessageListener.GetPointer());
            BOOST_REQUIRE(pEntry->IsSeq());
            pRetvalBioseq.Reset( & pEntry->SetSeq() );

            CSourceModParser::TMods unused_mods = fasta_reader.GetUnusedMods();
            set<string> unused_mods_as_strings;
            ITERATE(CSourceModParser::TMods, unused_mod_it, unused_mods) {
                unused_mods_as_strings.insert( unused_mod_it->key );
            }
            BOOST_CHECK_EQUAL_COLLECTIONS(
                unused_mods_as_strings.begin(), unused_mods_as_strings.end(),
                expected_unused_mods.begin(), expected_unused_mods.end() );
        } catch(const CException & ex ) {
            sErrCodeThatOccurred = ex.GetErrCodeString();
        } catch(...) {
            sErrCodeThatOccurred = "UNKNOWN";
        }

        // extract the warning codes
        TWarnVec pWarningTypes;
        ITERATE_0_IDX(ii, pMessageListener->Count()) {
            pWarningTypes.push_back(
                pMessageListener->GetError(ii).Problem() );
        }

        // check warnings
        BOOST_CHECK_EQUAL_COLLECTIONS(
            pExpectedWarningTypes.begin(), 
            pExpectedWarningTypes.end(),
            pWarningTypes.begin(),
            pWarningTypes.end() );

        // check error
        BOOST_CHECK_EQUAL( sExpectedExceptionErrCode, sErrCodeThatOccurred );

        return pRetvalBioseq;
    }

    // kludge to work around the inability to have templated typedefs
    template<typename TType>
    class TRefStd : public CConstRef<CObjectFor<TType> > { };

    // turns even a literal into a reference
    template<typename TType>
    TRefStd<TType> s_RefStd(const TType & value )
    {
        TRefStd<TType> pAnswer;
        pAnswer.Reset( new CObjectFor<TType>(value) );
        return pAnswer;
    }

    // lets us have nullable non-CObject data
    template<typename TType>
    TRefStd<TType> s_RefOrNull(
        bool bReturnNonNull,
        const TType & valueIfNonNull )
    {
        if( bReturnNonNull ) {
            return s_RefStd(valueIfNonNull);
        }
        return TRefStd<TType>();
    }

    template<typename TType>
    vector<TType> s_VecOfOne(
        const TType & value)
    {
        vector<TType> answerVec;
        answerVec.push_back(value);
        return answerVec;
    }

    // The given bioseq should have exactly one gap
    // The TRefStd's are NULL for "should be unset"
    void s_CheckOnlyBioseqGap(
                CConstRef<CBioseq> pBioseq,
                TRefStd<TSeqPos> pNumDeltasExpected,
                TRefStd<TSeqPos>  pGapLenExpected,
                TRefStd<CInt_fuzz::ELim> pLimExpected,
                TRefStd<CSeq_gap::EType> pGapTypeExpected,
                TRefStd< vector<CLinkage_evidence::EType> > pLinkEvidsExpected )
    {
        // check number of deltas
        const CDelta_ext::Tdata * pDeltaData = NULL;
        if (pBioseq->IsSetInst() && pBioseq->GetInst().IsSetExt() && pBioseq->GetInst().GetExt().IsDelta())
            pDeltaData = & pBioseq->GetInst().GetExt().GetDelta().Get();
        if( pNumDeltasExpected ) {
            if( pDeltaData ) {
                NCBITEST_CHECK_EQUAL(pDeltaData->size(), *pNumDeltasExpected);
            } else {
                BOOST_ERROR("no delta-ext's");
            }
        } else {
            NCBITEST_CHECK( ! pDeltaData );
        }

        // find the one gap seq-literal
        CConstRef<CSeq_literal> pGapLiteral;
        if( pDeltaData ) {
            ITERATE(CDelta_ext::Tdata, delta_it, *pDeltaData) {
                const CSeq_literal & seq_literal = 
                    (*delta_it)->GetLiteral();
                if( ! seq_literal.IsSetSeq_data() || 
                    FIELD_IS_SET_AND_IS(seq_literal, Seq_data, Gap) ) 
                {
                    // it's a gap
                    BOOST_REQUIRE_MESSAGE( ! pGapLiteral, 
                        "There should be only one gap" );
                    pGapLiteral.Reset( & seq_literal );
                }
            }
        }

        // check gap len
        if( pGapLenExpected ) {
            NCBITEST_CHECK_EQUAL( pGapLiteral->GetLength(), *pGapLenExpected );
        } else {
            NCBITEST_CHECK( ! pGapLiteral->IsSetLength() );
        }

        // check fuzz
        if( pLimExpected ) {
            NCBITEST_CHECK_EQUAL(
                pGapLiteral->GetFuzz().GetLim(), CInt_fuzz::eLim_unk);
        } else {
            BOOST_CHECK( ! pGapLiteral || ! pGapLiteral->IsSetFuzz() );
        }

        // extract CSeq_gap, if any
        CConstRef<CSeq_gap> pSeqGap;
        if (pGapLiteral->IsSetSeq_data() && pGapLiteral->GetSeq_data().IsGap())
            pSeqGap.Reset( & pGapLiteral->GetSeq_data().GetGap() );

        if( pGapTypeExpected ) {
            NCBITEST_CHECK_EQUAL(pSeqGap->GetType(), *pGapTypeExpected);
        } else {
            NCBITEST_CHECK( ! pSeqGap || ! pSeqGap->IsSetType() );
        }

        // check linkage and linkage-evidence
        if( pLinkEvidsExpected && pLinkEvidsExpected->GetData().empty() ) {
            // consider empty and unset to be the same thing
            // for our expected array and our actual array
            pLinkEvidsExpected.Reset();
        }
        if( pLinkEvidsExpected ) {
            NCBITEST_CHECK_EQUAL( pSeqGap->GetLinkage(), 
                CSeq_gap::eLinkage_linked );
        } else {
            NCBITEST_CHECK( ! pSeqGap || 
                ! FIELD_EQUALS(*pSeqGap, Linkage, CSeq_gap::eLinkage_linked) );
        }
        const CSeq_gap::TLinkage_evidence * pLinkEvidObjs = NULL;
        if (pSeqGap.NotNull() && pSeqGap->IsSetLinkage_evidence())
            pLinkEvidObjs = & pSeqGap->GetLinkage_evidence();
        if( pLinkEvidsExpected ) {
            vector<CLinkage_evidence::EType> vecLinkEvids;
            if( pLinkEvidObjs ) {
                ITERATE(CSeq_gap::TLinkage_evidence, evid_obj_it, *pLinkEvidObjs) {
                    BOOST_CHECK_NO_THROW(
                        vecLinkEvids.push_back( 
                            static_cast<CLinkage_evidence::EType>(
                                (*evid_obj_it)->GetType() ) ) );
                }
            }
            BOOST_CHECK_EQUAL_COLLECTIONS(
                pLinkEvidsExpected->GetData().begin(), 
                pLinkEvidsExpected->GetData().end(),
                vecLinkEvids.begin(), vecLinkEvids.end());
        } else {
            NCBITEST_CHECK( ! pLinkEvidObjs || 
                pLinkEvidObjs->empty() );
        }
    }
}


// Put in a bunch here for the ParseIDs
BOOST_AUTO_TEST_CASE(TestDefLineParser) 
{
    CFastaReader::SDefLineParseInfo parseInfo;
    parseInfo.maxIdLength = 40;
    parseInfo.lineNumber = 0;
    parseInfo.fFastaFlags = CFastaReader::fAllSeqIds;
    parseInfo.fBaseFlags = 0;

    CFastaReader::TIgnoredProblems noIgnoredErrors;
    list<CRef<CSeq_id>> ids;
    bool hasRange;
    TSeqPos rangeStart, rangeEnd;
    CFastaReader::TSeqTitles seqTitles;

    // Anything following a title\1 is interpreted as an ID 
    // unless a range has already been specified.
    // The string below thus contains three IDs.
    {
        static const string kFastaDefLine = 
            ">ID1 Title1\1ID2 Title2.1 Title2.2 \1[ID3]\n";
        CFastaReader::ParseDefLine(kFastaDefLine, 
                                   parseInfo,
                                   noIgnoredErrors,
                                   ids,
                                   hasRange,
                                   rangeStart,
                                   rangeEnd,
                                   seqTitles,
                                   nullptr); 

        BOOST_CHECK( ids.size() == 3 );
        BOOST_CHECK( !hasRange );
        BOOST_CHECK( seqTitles.size() == 2 );
        BOOST_CHECK( seqTitles[1].m_sLineText == "Title2.1 Title2.2 " );

        ids.clear();
        seqTitles.clear();
    }


    // If a range is encountered, do not search for any more IDs. 
    // ID2 is ignored in the string below.
    { 
        static const string kFastaDefLine = 
            ">ID1:123-456 Title\11D2\n";
        CFastaReader::ParseDefLine(kFastaDefLine, 
                                   parseInfo,
                                   noIgnoredErrors,
                                   ids,
                                   hasRange,
                                   rangeStart,
                                   rangeEnd,
                                   seqTitles,
                                   nullptr); 


        BOOST_CHECK( ids.size() == 1 );
        BOOST_CHECK( hasRange );
        BOOST_CHECK( rangeStart == 122 );
        BOOST_CHECK( rangeEnd == 455 );
        BOOST_CHECK( seqTitles.size() == 1 &&
                     seqTitles.front().m_sLineText == "Title" );
        ids.clear();
        seqTitles.clear();
    }


    // ID3 is ignorned in the string below, due to the appearance of 
    // a range after ID2.
    {
        static const string kFastaDefLine = 
            ">ID1 Title1 \1ID2:12-34 Title2 \1ID3 \n";
        CFastaReader::ParseDefLine(kFastaDefLine, 
                                   parseInfo,
                                   noIgnoredErrors,
                                   ids,
                                   hasRange,
                                   rangeStart,
                                   rangeEnd,
                                   seqTitles,
                                   nullptr); 



        BOOST_CHECK( ids.size() == 2 );
        BOOST_CHECK( hasRange );
        BOOST_CHECK( rangeStart == 11 );
        BOOST_CHECK( rangeEnd == 33 );
        BOOST_CHECK( seqTitles.size() == 2 );
        BOOST_CHECK( seqTitles.front().m_sLineText == "Title1 " );
        BOOST_CHECK( seqTitles.back().m_sLineText == "Title2 " );

        ids.clear();
        seqTitles.clear();
    }


    // Check that lcl|... is handled correctly
    {
        static const string kFastaDefLine = 
            ">lcl|ID1 Title\n";
        CFastaReader::ParseDefLine(kFastaDefLine, 
                                   parseInfo,
                                   noIgnoredErrors,
                                   ids,
                                   hasRange,
                                   rangeStart,
                                   rangeEnd,
                                   seqTitles,
                                   nullptr); 

        BOOST_CHECK ( ids.size() == 1 );
        const CRef<CSeq_id>& localId = ids.front();
        BOOST_CHECK( localId->GetLocal().IsStr() &&
                     localId->GetLocal().GetStr() == "ID1" );

        ids.clear();
        seqTitles.clear();
    }

    // Check that Genbank accessions are read correctly
    {
        static const string kFastaDefLine = 
            ">gb|M73307";
        CFastaReader::ParseDefLine(kFastaDefLine, 
                                   parseInfo,
                                   noIgnoredErrors,
                                   ids,
                                   hasRange,
                                   rangeStart,
                                   rangeEnd,
                                   seqTitles,
                                   nullptr); 

        BOOST_CHECK( ids.size() == 1 );
        BOOST_CHECK( !hasRange );
        BOOST_CHECK( seqTitles.empty() );
        BOOST_CHECK( ids.front()->IsGenbank() &&
                     ids.front()->GetGenbank().GetAccession() == "M73307");

        ids.clear();
        seqTitles.clear();
    }


    // Check that the following is interpreted as a defline 
    // modifier, not an ID.
    {
        static const string kFastaDefLine = 
            ">[topology=linear]";
        CFastaReader::ParseDefLine(kFastaDefLine, 
                                   parseInfo,
                                   noIgnoredErrors,
                                   ids,
                                   hasRange,
                                   rangeStart,
                                   rangeEnd,
                                   seqTitles,
                                   nullptr); 

        BOOST_CHECK( ids.empty() );
        BOOST_CHECK( !hasRange );
        BOOST_CHECK( seqTitles.size() == 1 );

        ids.clear();
        seqTitles.clear();
    }
}




BOOST_AUTO_TEST_CASE(TestTitleRemovedIfEmpty)
{
    static const string kFastaWhereAllModsRemoved = 
        ">Seq1 [topology=circular]\n"
        "ACGTACGTACGTACGTACGTACGTACGTACGTACGT\n";
    CRef<CBioseq> pBioseq = s_ParseFasta( kFastaWhereAllModsRemoved,
        CFastaReader::fAddMods );
    BOOST_REQUIRE(pBioseq);

    FOR_EACH_SEQDESC_ON_BIOSEQ(desc_it, *pBioseq) {
        BOOST_CHECK( ! (*desc_it)->IsTitle() );
    }
}





BOOST_AUTO_TEST_CASE(TestProteinSeqGapChar)
{
    static const string kFastaWithProtGap = 
        ">Dobi [organism=Canis familiaris] [breed=Doberman pinscher]\n"
        "MMMTGCMTGGGTMMMMGTMGTMGMMGMGMMGGCTTTTMGCCCMGMMGTMMTMCCCMTGTTTTCMGCMTTM\n"
        "GGMMMMMGGGCTGTTG\n"
        ">?unk100\n"
        "TGGMTGMCMGMMMCCTTGTTGGTCCMMMMTGCMMMCCCMGMTKGTMMGMCCMTTTTMMMMGCMTTGGGTC\n"
        "TTMGMMMTMGGGCMMCMCMGMMCMMMMMT\n"
        ">?234\n"
        "MMMMMTMMMMGCMTTMGTMGMMMTTTGTMCMGMMCTGGMMMMGGMMGGMMMMMTTTCMMMMMTTGGGCCT\n";

    CFastaReader::TFlags fFastaReaderFlags =
        CFastaReader::fAddMods | 
        CFastaReader::fAssumeProt |
        CFastaReader::fUseIupacaa;

    // test with and without nosplit
    ITERATE_BOTH_BOOL_VALUES(bSetNoSplit) {
        cout << "Trying with" << (bSetNoSplit ? "" : "out") << " CFastaReader::fNoSplit" << endl;
        BOOST_CHECK(s_ParseFasta( kFastaWithProtGap, 
            fFastaReaderFlags | (bSetNoSplit ? CFastaReader::fNoSplit : 0)));
    }
}

// Make sure [protein=whatever] doesn't work
// on nuc sequences but does work on prots.
// Also, "[gene=...]" becomes a feature on a nuc,
// but is an xref on a prot
BOOST_AUTO_TEST_CASE(TestGeneAndProtein)
{
    {{
        static const string kFastaNuc = 
            ">Seq1 [gene=some_gene] [protein=foo]\n"
            "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTAC\n";

        set<string> expected_unused_mods;
        expected_unused_mods.insert("protein");

        CRef<CBioseq> pBioseq = s_ParseFasta(
            kFastaNuc, CFastaReader::fAddMods,
            kEmptyStr, TWarnVec(), 
            CRef<CSourceModParser::CModFilter>(),
            expected_unused_mods );
        BOOST_REQUIRE(pBioseq);

        bool bFoundGene = false;

        CTypeConstIterator<CSeqFeatData> seqfeatdat_ci(Begin(*pBioseq));
        for( ; seqfeatdat_ci; ++seqfeatdat_ci ) {
            BOOST_REQUIRE( ! seqfeatdat_ci->IsProt() );
            if( FIELD_IS_AND_IS_SET(*seqfeatdat_ci, Gene, Locus) && 
                seqfeatdat_ci->GetGene().GetLocus() == "some_gene" )
            {
                bFoundGene = true;
            }
        }

        BOOST_CHECK(bFoundGene);
    }}

    {{
        static const string kFastaProt =
            ">Seq1 [gene=some_gene] [protein=foo]\n"
            "MALWMHLLTVLALLALWGPNTNQAFVSRHLCGSNLVETLYSVCQDDGFFYIPKDRRELED\n";

        set<string> expected_unused_mods;
        expected_unused_mods.insert("gene");

        CRef<CBioseq> pBioseq = s_ParseFasta(
            kFastaProt, CFastaReader::fAddMods,
            kEmptyStr, TWarnVec(), 
            CRef<CSourceModParser::CModFilter>(),
            expected_unused_mods );
        BOOST_REQUIRE(pBioseq);

        bool bHasProt = false;
        CTypeConstIterator<CSeq_feat> seqfeat_ci(Begin(*pBioseq));
        for( ; seqfeat_ci; ++seqfeat_ci ) {
            BOOST_CHECK( ! FIELD_IS_SET_AND_IS(*seqfeat_ci, Data, Gene) );
            if( FIELD_IS_SET_AND_IS(*seqfeat_ci, Data, Prot) ) {
                bHasProt = true;
                NCBITEST_CHECK( RAW_FIELD_IS_EMPTY_OR_UNSET(*seqfeat_ci, Xref) );
            }
        }
        BOOST_CHECK(bHasProt);
    }}
}

BOOST_AUTO_TEST_CASE(TestGapMods)
{
    const string kPreGapNucs = 
        "GATTACAACGTGATTACAACGTGATTACAACGTGATTACAACGTGATTACAACGTGATTACA";
    const string kPostGapNucs[2] = {
        "TCGACCCACGCGTCCGGAGAAGTTTTTCACCTACTGGAACCCGCCTAGGGTACGGGAAAC",
        "AGGTGCCCTCCAAAACGAGAGCGCGAACTGCAGCCTACGTCCCACTGCAGCTCAGGAGCA"
    };

    const string kLinesBeforeGap = 
        ">Seq1\n" +
        kPreGapNucs + "\n";
    const string kLinesAfterGap = 
        kPostGapNucs[0] + "\n" +
        kPostGapNucs[1] + "\n";

    // the 2 above, plus a gap line added in-between
    const TSeqPos kNumDeltasExpected = 3;

    // arbitrary gap length to use when the length doesn't matter
    const TSeqPos kArbGapLen = 42;

    const CFastaReader::TFlags kDefaultFastaFlags = 
        CFastaReader::fParseGaps;

    // test that numbers other than kUnknownGapLen will work
    // (no values provided should imply [gap-type=unknown][linkage-evidence=unspecified])
    // (and test that negative or zero fails)
    ITERATE_BOTH_BOOL_VALUES(bIsUnknown) {
        const int arrGapLensToTry[] = {-250, -8, 0, 1, 20, 84, 100, 158, 2093};
        ITERATE_0_IDX(gapLenIdx, ArraySize(arrGapLensToTry) ) {
            const int iGapLen = arrGapLensToTry[gapLenIdx];
            const string sDataToRead = kLinesBeforeGap + ">?" + 
                ( bIsUnknown ? "unk" : "") + 
                NStr::NumericToString(iGapLen) + "\n" + kLinesAfterGap;

            cerr << "Testing with " << (bIsUnknown ? "unknown" : "known") 
                 << " gap size of " << iGapLen << endl;

            // non-positive gap sizes should create a warning
            TWarnVec expectedWarningsVec;

            if( iGapLen <= 0 ) {
                expectedWarningsVec.push_back( 
                    ILineError::eProblem_NonPositiveLength );
            }

            if( iGapLen < 0 ) {
                // in this case, the negative length is
                // interpreted as a 
                expectedWarningsVec.push_back( 
                    ILineError::eProblem_ParsingModifiers );
            }

            CRef<CBioseq> pBioseq = s_ParseFasta(
                sDataToRead, kDefaultFastaFlags, 
                kEmptyStr, expectedWarningsVec );

            // non-positive gap sizes should create a format error
            if( iGapLen <= 0 ) {
                continue;
            }

            const int iExpectedGapLen = iGapLen;

            s_CheckOnlyBioseqGap(
                pBioseq,
                s_RefStd(kNumDeltasExpected),
                s_RefStd( static_cast<TSeqPos>(iExpectedGapLen) ),
                s_RefOrNull(bIsUnknown, CInt_fuzz::eLim_unk),
                TRefStd<CSeq_gap::EType>(),
                TRefStd<vector<CLinkage_evidence::EType> >() );
        }
    }

    // test possible gap types
    const CSeq_gap::TGapTypeMap & gapTypeMap = CSeq_gap::GetNameToGapTypeInfoMap();

    ITERATE_BOTH_BOOL_VALUES(bPutLinkEvidInInput) {
        ITERATE( CSeq_gap::TGapTypeMap, gap_type_text_it, gapTypeMap )
        {
            const char *pchGapType = gap_type_text_it->first;
            const CSeq_gap::SGapTypeInfo & gapTypeInfo =
                gap_type_text_it->second;

            // build the data we're reading;
            CNcbiOstrstream fasta_in_strm;
            fasta_in_strm << kLinesBeforeGap
            << ">?unk" << kArbGapLen
            << " [gap-type=" << pchGapType << ']';
            if( bPutLinkEvidInInput ) {
                fasta_in_strm << " [linkage-evidence=pcr]";
            }
            fasta_in_strm << '\n';
            fasta_in_strm << kLinesAfterGap;

            // print what we're doing here
            cerr << "Testing gap-type " << pchGapType << "("
                 << (bPutLinkEvidInInput ? "with" : "without" ) 
                 << " a linkage-evidence)" << endl;

            TWarnVec expectedWarningsVec;
            if( bPutLinkEvidInInput ) 
            {
                if( gapTypeInfo.m_eLinkEvid == CSeq_gap::eLinkEvid_Forbidden ) {
                    expectedWarningsVec.push_back(
                        ILineError::eProblem_ModifierFoundButNoneExpected);
                } else if( gapTypeInfo.m_eLinkEvid == CSeq_gap::eLinkEvid_UnspecifiedOnly ) {
                    expectedWarningsVec.push_back(
                        ILineError::eProblem_ExtraModifierFound);
                }
            } else {
                if(gapTypeInfo.m_eLinkEvid == CSeq_gap::eLinkEvid_Required ) 
                {
                    expectedWarningsVec.push_back(
                        ILineError::eProblem_ExpectedModifierMissing);
                }
            }

            CRef<CBioseq> pBioseq =
                s_ParseFasta(
                    CNcbiOstrstreamToString(fasta_in_strm),
                    kDefaultFastaFlags,
                    kEmptyStr,
                    expectedWarningsVec);
              
            // add checking function
            s_CheckOnlyBioseqGap(
                pBioseq,
                s_RefStd(kNumDeltasExpected),
                s_RefStd(kArbGapLen),
                s_RefStd(CInt_fuzz::eLim_unk),
                s_RefStd(gapTypeInfo.m_eType),
                s_RefOrNull(gapTypeInfo.m_eLinkEvid != CSeq_gap::eLinkEvid_Forbidden,                 
                    s_VecOfOne(
                        gapTypeInfo.m_eLinkEvid == CSeq_gap::eLinkEvid_Required &&
                            bPutLinkEvidInInput ?
                        CLinkage_evidence::eType_pcr :
                        CLinkage_evidence::eType_unspecified)) );
        }
    }

    // test interaction with "unspecified"
    ITERATE( CSeq_gap::TGapTypeMap, gap_type_text_it, gapTypeMap )
    {
        const char *pchGapType = gap_type_text_it->first;
        const CSeq_gap::SGapTypeInfo & gapTypeInfo = gap_type_text_it->second;

        // build the data we're reading;
        CNcbiOstrstream fasta_in_strm;
        fasta_in_strm << kLinesBeforeGap
            << ">?unk" << kArbGapLen
            << " [gap-type=" << pchGapType << ']'
            << " [linkage-evidence=unspecified]\n"
            << kLinesAfterGap;

        // print what we're doing here
        cerr << "Testing gap-type " << pchGapType << " with 'unspecified'" << endl;

        TWarnVec expectedWarningsVec;
        switch( gapTypeInfo.m_eLinkEvid ) {
        case CSeq_gap::eLinkEvid_UnspecifiedOnly:
            // no problem
            break;
        case CSeq_gap::eLinkEvid_Required:
            expectedWarningsVec.push_back(
                ILineError::eProblem_ExpectedModifierMissing);
            break;
        case CSeq_gap::eLinkEvid_Forbidden:
            expectedWarningsVec.push_back(
                ILineError::eProblem_ModifierFoundButNoneExpected);
            break;
        default:
            BOOST_FAIL("Unknown CSeq_gap::ELinkEvid: " 
                << static_cast<int>(gapTypeInfo.m_eLinkEvid) );
            break;
        }

        CRef<CBioseq> pBioseq =
            s_ParseFasta(
            CNcbiOstrstreamToString(fasta_in_strm),
            kDefaultFastaFlags,
            kEmptyStr,
            expectedWarningsVec);

        // add checking function
        s_CheckOnlyBioseqGap(
            pBioseq,
            s_RefStd(kNumDeltasExpected),
            s_RefStd(kArbGapLen),
            s_RefStd(CInt_fuzz::eLim_unk),
            s_RefStd(gapTypeInfo.m_eType),
            s_RefOrNull(
                gapTypeInfo.m_eLinkEvid != CSeq_gap::eLinkEvid_Forbidden, 
                s_VecOfOne(CLinkage_evidence::eType_unspecified)) );
    }

    // test format errors after gap length
    {
        struct {
            const char * gap_mods;
            ILineError::EProblem problem_arr[2];
        }
        arrBadGapMods[] = {
            // bogus mod key
            { " [foo=baz]", 
              { ILineError::eProblem_UnrecognizedQualifierName,
              ILineError::eProblem_Unset } },
            // bogus gap type
            { " [gap-type=foo]",
              { ILineError::eProblem_ParsingModifiers,
              ILineError::eProblem_Unset } },
            // bogus linkage-evidence
            { " [gap-type=between scaffolds] [linkage-evidence=foo]",
              { ILineError::eProblem_ParsingModifiers,
                ILineError::eProblem_ExpectedModifierMissing } },
            // extra junk on gap line (even if good mods)
            { " extra junk",
              { ILineError::eProblem_ParsingModifiers,
                ILineError::eProblem_Unset } },
            { " [gap-type=short arm] extra junk",
              { ILineError::eProblem_ParsingModifiers,
                ILineError::eProblem_Unset } },
            { " [gap-type=short arm] extra junk [linkage-evidence=map]",
              { ILineError::eProblem_ParsingModifiers,
                ILineError::eProblem_Unset } },
            // conflicting gap types
            { " [gap-type=short arm] [gap-type=heterochromatin]",
              { ILineError::eProblem_ContradictoryModifiers,
                ILineError::eProblem_Unset } }
        };
        const size_t arrBadGapMods_len = sizeof(arrBadGapMods) / sizeof(arrBadGapMods[0]);
        ITERATE_0_IDX( ii, arrBadGapMods_len ) {
            const string sDataToRead = kLinesBeforeGap +
                ">?unk" + NStr::NumericToString(kArbGapLen) +
                arrBadGapMods[ii].gap_mods + "\n" + kLinesAfterGap;

            TWarnVec expectedWarningsVec;
            expectedWarningsVec.push_back(
                arrBadGapMods[ii].problem_arr[0] );
            if( arrBadGapMods[ii].problem_arr[1] != 
                ILineError::eProblem_Unset ) 
            {
                expectedWarningsVec.push_back(
                    arrBadGapMods[ii].problem_arr[1] );
            }

            CRef<CBioseq> pBioseq =
                s_ParseFasta(
                sDataToRead,
                kDefaultFastaFlags,
                kEmptyStr,
                expectedWarningsVec );
        }
    }

    // test multiple linkage evidences (both approaches)
    {
        // all ways should give the same result
        const char * arrLinkageEvidences[] = {
            // shouldn't matter if all in one semi-colon-separated mod
            // or split across multiple ones
            "[linkage-evidence=pcr;strobe;map]",
            "[linkage-evidence=pcr][linkage-evidence=strobe][linkage-evidence=map]",
            "[linkage-evidence=pcr;strobe][linkage-evidence=map]",
            "[linkage-evidence=pcr][linkage-evidence=strobe;map]",
            // dups should be ignored
            "[linkage-evidence=pcr;strobe;pcr;map]",
            "[linkage-evidence=pcr][linkage-evidence=strobe][linkage-evidence=pcr][linkage-evidence=map]"
        };

        // same result every iteration, so just build it here
        vector<CLinkage_evidence::EType> vecExpectedLinkEvids;
        vecExpectedLinkEvids.push_back(CLinkage_evidence::eType_pcr);
        vecExpectedLinkEvids.push_back(CLinkage_evidence::eType_strobe);
        vecExpectedLinkEvids.push_back(CLinkage_evidence::eType_map);
        sort( vecExpectedLinkEvids.begin(), vecExpectedLinkEvids.end() );

        ITERATE_0_IDX(linkEvidIdx, ArraySize(arrLinkageEvidences) ) {
            const char * pchLinkageEvidences = 
                arrLinkageEvidences[linkEvidIdx];

            cerr << "Trying: " << pchLinkageEvidences << endl;

            const string sDataToRead = kLinesBeforeGap +
                ">?" + NStr::NumericToString(kArbGapLen) +
                " [gap-type=between scaffolds] " + pchLinkageEvidences + "\n" + 
                kLinesAfterGap;

            CRef<CBioseq> pBioseq =
                s_ParseFasta(sDataToRead, kDefaultFastaFlags);

            BOOST_REQUIRE( pBioseq );

            s_CheckOnlyBioseqGap(
                pBioseq,
                s_RefStd(kNumDeltasExpected),
                s_RefStd(kArbGapLen),
                TRefStd<CInt_fuzz::ELim>(),
                s_RefStd(CSeq_gap::eType_contig),
                s_RefStd(vecExpectedLinkEvids) );
        }
    }

    // test that canonicalization does work
    // (that is, case, etc. is ignored)
    {
        const string sDataToRead = kLinesBeforeGap +
            ">?" + NStr::NumericToString(kArbGapLen) +
            " [  GAP tYpe  =   Between_Scaffolds  ] [ linkage_evidence  = Align xgenus   ]\n" + 
            kLinesAfterGap;

        CRef<CBioseq> pBioseq =
            s_ParseFasta(
            sDataToRead,
            kDefaultFastaFlags);

        BOOST_REQUIRE( pBioseq );

        vector<CLinkage_evidence::EType> vecExpectedLinkEvids(
            1, CLinkage_evidence::eType_align_xgenus);
        
        s_CheckOnlyBioseqGap(
            pBioseq,
            s_RefStd(kNumDeltasExpected),
            s_RefStd(kArbGapLen),
            TRefStd<CInt_fuzz::ELim>(),
            s_RefStd(CSeq_gap::eType_contig),
            s_RefStd(s_VecOfOne(CLinkage_evidence::eType_align_xgenus)) );
    }
}

BOOST_AUTO_TEST_CASE(TestNonDeltaGaps)
{
    const string kDefline = ">Seq1";
    const string kNucsBeforeGap = 
        "GATTACAACGTGATTACAACGTGATTACAAC";
    // arbitrary kArbGapSize, but used prime to make accidentally correct 
    // results less likely 
    const TSeqPos kArbGapSize = 17;
    const string kNucsAfterGap = "GTGATTACAACGTGATTACAACGTGATTACA";

    const string kExpectedBasesIfKnown = kNucsBeforeGap + 
        string(kArbGapSize, 'N') +
        kNucsAfterGap;
    const string kExpectedBasesIfUnknown = kNucsBeforeGap + 
        string(kArbGapSize, 'N') +
        kNucsAfterGap;
    // test if the fParseGaps flag is NOT set, which would result in 
    // one big sequence (no deltas).

    // all these different representations should result in a gap
    // of the same size
    const string arrGapStrings[] = {
        string(kArbGapSize, 'N'),
        string(kArbGapSize, '-'),
        "\n>?" + NStr::NumericToString(kArbGapSize) + "\n",
        "\n>?unk" + NStr::NumericToString(kArbGapSize) + "\n",
        "\n>?unk" + NStr::NumericToString(kArbGapSize) + 
            " [gap-type=unknown]  [linkage-evidence=unspecified]\n",
        "\n>?unk" + NStr::NumericToString(kArbGapSize) + 
            " [gap-type=repeat within scaffold]  [linkage-evidence=pcr]\n"
    };
    ITERATE_0_IDX( gap_str_idx, ArraySize(arrGapStrings) ) {
        const string & sGapString = arrGapStrings[gap_str_idx];
        const string sDataToRead =
            kDefline + "\n" +
            kNucsBeforeGap + sGapString + kNucsAfterGap + "\n";

        // if there are substantive mods on the gaps, a warning
        // is expected
        TWarnVec expectedWarnings;
        if( sDataToRead.find('[') != string::npos && 
            sDataToRead.find("unknown") == string::npos ) 
        {
            expectedWarnings.push_back(
                ILineError::eProblem_ModifierFoundButNoneExpected);
        }

        CRef<CBioseq> pBioseq =
            s_ParseFasta(sDataToRead, 0, 
                kEmptyStr, expectedWarnings);

        BOOST_REQUIRE( pBioseq );

        // should NOT contain a gap per se
        NCBITEST_CHECK( ! pBioseq->GetInst().GetSeq_data().IsGap() );

        CSeqVector seq_vec(*pBioseq, NULL, CBioseq_Handle::eCoding_Iupac);

        const string & kExpectedBases = kExpectedBasesIfKnown;

        BOOST_CHECK_EQUAL_COLLECTIONS(
            kExpectedBases.begin(), kExpectedBases.end(),
            seq_vec.begin(), seq_vec.end() );
    }
}

BOOST_AUTO_TEST_CASE(TestLetterGaps)
{
    const string kFasta =
        ">lcl|Seq1\n"
        "AC---NNNNNNNNNACGTGATTACAN\n"
        ">?48\n"
        "ACGTACGT\n"
        "GATTACA\n"
        ">?unk50\n"
        "ACGT---GA-TTNACAN\n"
        ">?1\n"
        "ACGTACGT\n"
        ">?unk1\n"
        "GATTAACGTTATGC\n"
        "CGATTAACGTTATGCN\n"
        "GGATTAACGTTATGC-N\n"
        "TGATTAACGTTATGC\n"
        ">?42\n"
        ">?37\n"
        ">?unk20\n"
        "ACGTTGCA\n";

    const string kExpectedDeltaExt =
        "Delta-ext ::= {\n"
        "  literal {\n"
        "    length 2,\n"
        "    seq-data ncbi4na '12'H\n"
        "  },\n"
        "  literal {\n"
        "    length 12\n"
        "  },\n"
        "  literal {\n"
        "    length 11,\n"
        "    seq-data ncbi2na '1B8F10'H\n"
        "  },\n"
        "  literal {\n"
        "    length 1\n"
        "  },\n"
        "  literal {\n"
        "    length 48\n"
        "  },\n"
        "  literal {\n"
        "    length 15,\n"
        "    seq-data ncbi2na '1B1B8F10'H\n"
        "  },\n"
        "  literal {\n"
        "    length 50,\n"
        "    fuzz lim unk\n"
        "  },\n"
        "  literal {\n"
        "    length 4,\n"
        "    seq-data ncbi2na '1B'H\n"
        "  },\n"
        "  literal {\n"
        "    length 3\n"
        "  },\n"
        "  literal {\n"
        "    length 2,\n"
        "    seq-data ncbi4na '41'H\n"
        "  },\n"
        "  literal {\n"
        "    length 1\n"
        "  },\n"
        "  literal {\n"
        "    length 2,\n"
        "    seq-data ncbi4na '88'H\n"
        "  },\n"
        "  literal {\n"
        "    length 1\n"
        "  },\n"
        "  literal {\n"
        "    length 3,\n"
        "    seq-data ncbi2na '10'H\n"
        "  },\n"
        "  literal {\n"
        "    length 1\n"
        "  },\n"
        "  literal {\n"
        "    length 1\n"
        "  },\n"
        "  literal {\n"
        "    length 8,\n"
        "    seq-data ncbi2na '1B1B'H\n"
        "  },\n"
        "  literal {\n"
        "    length 1,\n"
        "    fuzz lim unk\n"
        "  },\n"
        "  literal {\n"
        "    length 29,\n"
        "    seq-data ncbi2na '8F06F3963C1BCE40'H\n"
        "  },\n"
        "  literal {\n"
        "    length 1\n"
        "  },\n"
        "  literal {\n"
        "    length 15,\n"
        "    seq-data ncbi2na 'A3C1BCE4'H\n"
        "  },\n"
        "  literal {\n"
        "    length 2\n"
        "  },\n"
        "  literal {\n"
        "    length 15,\n"
        "    seq-data ncbi2na 'E3C1BCE4'H\n"
        "  },\n"
        "  literal {\n"
        "    length 42\n"
        "  },\n"
        "  literal {\n"
        "    length 37\n"
        "  },\n"
        "  literal {\n"
        "    length 20,\n"
        "    fuzz lim unk\n"
        "  },\n"
        "  literal {\n"
        "    length 8,\n"
        "    seq-data ncbi2na '1BE4'H\n"
        "  }\n"
        "}\n";

    CAutoInitRef<CDelta_ext> pExpectedDeltaExt;
    s_LoadObjectRefFromTextASN(pExpectedDeltaExt, kExpectedDeltaExt);
    
    TWarnVec expectedWarningsVec;

    CRef<CBioseq> pBioseq =
        s_ParseFasta(kFasta, 
        CFastaReader::fParseGaps |
        CFastaReader::fLetterGaps |
        CFastaReader::fAssumeNuc,
        kEmptyStr, 
        expectedWarningsVec );

    CConstRef<CDelta_ext> pResultingDeltaExt( 
        & pBioseq->GetInst().GetExt().GetDelta() );
    if( ! pResultingDeltaExt->Equals( 
        *pExpectedDeltaExt ) )
    {
        BOOST_ERROR("Delta-ext differs from expected.");
        cerr << "Expected: " << MSerial_AsnText << *pExpectedDeltaExt << endl;
        cerr << "Received: " << MSerial_AsnText << *pResultingDeltaExt << endl;
    }
}

// Not sure what to do about this since lone end-of-line hyphens
// produce weird results

//BOOST_AUTO_TEST_CASE(TestLoneEndOfLineHyphens)
//{
//    const string kFasta =
//        ">Seq1\n"
//        "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA-\n"
//        "GTACGTACGTACGT\n"
//        ">?58\n"
//        "CGGTACGTACGTACGT\n"
//        ">?unk90\n"
//        "AAACGGTACGTACGTACGT\n";
//
//    const string kCompletelyUnknownGap =
//        "Delta-seq ::= \n"
//        "loc null NULL\n";
//    CAutoInitRef<CDelta_seq> pCompletelyUnknownGap;
//    s_LoadObjectRefFromTextASN(pCompletelyUnknownGap, kCompletelyUnknownGap);
//
//    const string kRegularUnknownGap =
//        "Delta-seq ::= \n"
//        "literal {\n"
//        "  length 100,\n"
//        "  fuzz lim unk\n"
//        "}\n";
//    // length of pRegularUnknownGap may be adjusted as we go
//    CAutoInitRef<CDelta_seq> pRegularUnknownGap;
//    s_LoadObjectRefFromTextASN(pRegularUnknownGap, kRegularUnknownGap);
//
//    const string kRegularGap =
//        "Delta-seq ::= \n"
//        "literal {\n"
//        "  length 100\n"
//        "}\n";
//    // length of pRegularGap may be adjusted as we go
//    CAutoInitRef<CDelta_seq> pRegularGap;
//    s_LoadObjectRefFromTextASN(pRegularGap, kRegularGap);
//
//    ITERATE_BOTH_BOOL_VALUES(bSetCompletelyUnknownGapLen) {
//        CRef<CBioseq> pBioseq =
//            s_ParseFasta(kFasta, 
//            CFastaReader::fParseGaps | CFastaReader::fAssumeNuc,
//            kEmptyStr,
//            TWarnVec(),
//            ( bSetCompletelyUnknownGapLen ? 100 : 0 ) );
//
//        const CDelta_ext::Tdata & delta_seqs = 
//            pBioseq->GetInst().GetExt().GetDelta().Get();
//        CDelta_ext::Tdata::const_iterator delta_seq_it = delta_seqs.begin();
//
//        NCBITEST_CHECK( 
//            FIELD_IS_AND_IS_SET( **delta_seq_it, Literal, Seq_data ) );
//
//        ++delta_seq_it;
//        if( bSetCompletelyUnknownGapLen ) {
//            pRegularUnknownGap->SetLiteral().SetLength(100);
//            NCBITEST_CHECK(
//                (*delta_seq_it)->Equals(*pRegularUnknownGap) );
//        } else {
//            NCBITEST_CHECK( 
//                (*delta_seq_it)->Equals(*pCompletelyUnknownGap) );
//        }
//
//        ++delta_seq_it;
//        NCBITEST_CHECK( 
//            FIELD_IS_AND_IS_SET( **delta_seq_it, Literal, Seq_data ) );
//
//        ++delta_seq_it;
//        pRegularGap->SetLiteral().SetLength(58);
//        NCBITEST_CHECK(
//            (*delta_seq_it)->Equals(*pRegularGap) );
//
//        ++delta_seq_it;
//        NCBITEST_CHECK( 
//            FIELD_IS_AND_IS_SET( **delta_seq_it, Literal, Seq_data ) );
//
//        ++delta_seq_it;
//        pRegularUnknownGap->SetLiteral().SetLength(90);
//        NCBITEST_CHECK(
//                (*delta_seq_it)->Equals(*pRegularUnknownGap) );
//
//        ++delta_seq_it;
//        NCBITEST_CHECK( 
//            FIELD_IS_AND_IS_SET( **delta_seq_it, Literal, Seq_data ) );
//    }
//}

BOOST_AUTO_TEST_CASE(TestHyphensIgnoreAndWarn)
{
    const string kFasta =
        ">Seq1\n"
        "ACGTACGTACGTACGTACGTACGTA---CGTACGTACGTACGTACGTACGTA-\n"
        "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA\n"
        "ACGTACGTACGTACG----TACGTA---CGTACGTACGTACGTACGTACGTA-\n";

    TWarnVec expectedWarnings;
    ITERATE_0_IDX(dummy, 2) {
        expectedWarnings.push_back( ILineError::eProblem_IgnoredResidue );
    }

    CRef<CBioseq> pBioseq =
        s_ParseFasta(kFasta, 
        CFastaReader::fHyphensIgnoreAndWarn,
        kEmptyStr,
        expectedWarnings );

    // ignored, but shouldn't cause an error
    BOOST_CHECK( pBioseq );

    // make sure answer is the correct length
    {{
        // calculate num bases expected
        string::size_type next_char_idx = 0;
        // skip first line, which is a defline
        next_char_idx = kFasta.find('\n');
        BOOST_CHECK_NE( next_char_idx, string::npos );
        ++next_char_idx;
        BOOST_CHECK_LT( next_char_idx, kFasta.length() );

        size_t uNumBasesExpected = 0;
        for( ; next_char_idx < kFasta.length(); ++next_char_idx ) {
            const char ch = kFasta[next_char_idx];
            if( isalpha(ch) ) {
                ++uNumBasesExpected;
            }
        }

        BOOST_CHECK_EQUAL( uNumBasesExpected, pBioseq->GetLength() );
    }}
}

BOOST_AUTO_TEST_CASE(TestIgnoringSpacesAfterGreaterThanInDefline)
{
    const string kLocalId = "Seq1";
    const string kSeq = "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA";

    ITERATE_0_IDX(num_spaces, 3) {
        const string sDefline = 
            ">" + string(num_spaces, ' ') + kLocalId;

        cout << "Trying with defline '" << sDefline << "'" << endl;

        const string sFastaToParse =
            sDefline + "\n" +
            kSeq + "\n";

        CRef<CBioseq> pBioseq =
            s_ParseFasta(sFastaToParse, 
            kDefaultFastaReaderFlags );

        BOOST_CHECK( pBioseq );

        NCBITEST_CHECK_EQUAL( 
            pBioseq->GetFirstId()->GetLocal().GetStr(),
            kLocalId );

        CSeqVector seqvec( *pBioseq, NULL, CBioseq_Handle::eCoding_Iupac );
        BOOST_CHECK_EQUAL_COLLECTIONS(
            kSeq.begin(), kSeq.end(),
            seqvec.begin(), seqvec.end() );
    }
}

BOOST_AUTO_TEST_CASE(TestModFilter)
{
    const string kData = ">Seq1 Seq2 [topology=circular] [org=ia io] [taxid=123]\n"
        "ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA\n";

    // a filter that filters out org mods only.
    class COrgModFilter : public CSourceModParser::CModFilter
    {
    public:
        virtual bool operator()( const CTempString & mod_name ) {
            return ( mod_name != "org" && mod_name != "taxid" );
        }
    };
    CRef<CSourceModParser::CModFilter> pModFilter( new COrgModFilter );

    ITERATE_BOTH_BOOL_VALUES( bUseFilter ) {

        set<string> expected_unused_mods;
        if( bUseFilter ) {
            expected_unused_mods.insert( "org" );
            expected_unused_mods.insert( "taxid" );
        }

        CRef<CBioseq> pBioseq = 
            s_ParseFasta( kData,
            CFastaReader::fAddMods,
            kEmptyStr,
            TWarnVec(),
            ( bUseFilter ? pModFilter : CRef<CSourceModParser::CModFilter>() ),
            expected_unused_mods );
        
        cout << MSerial_AsnText << *pBioseq << endl;

        // check if pBioseq has an org
        bool has_org = false;
        FOR_EACH_SEQDESC_ON_BIOSEQ(desc_it, *pBioseq) {
            if( FIELD_IS_AND_IS_SET(**desc_it, Source, Org) ) {
                has_org = true;
                break;
            }
        }

        BOOST_CHECK_EQUAL( has_org, ! bUseFilter );
    }
}
